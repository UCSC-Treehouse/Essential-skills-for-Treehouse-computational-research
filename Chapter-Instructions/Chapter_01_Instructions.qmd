---
title: "Chapter 1, Data Visualization"
format: gfm
---

In this first chapter we will explore data visualization with **ggplot2**: navigating variables, distribution, plots, and varying aesthetic options.

Additionally, you will learn how to create a new branch on GitHub and push your Chapter 1 work to that branch, creating a pull request in the process.
This pull request will allow a mentor to review your work each chapter.

------------------------------------------------------------------------

## Prerequisites

But, where are you going to store all of this new data analysis?
That's the job of Quarto notebooks.
For each chapter you work through, you will create a new quarto document *and* a new GitHub branch where you will push your corresponding chapters' work to.

**Create Your First GitHub Branch**

1. Before you return to RStudio to create your first quarto notebook, you want to create a new branch on GitHub where you can push that chapter's work.

- In **GitHub Desktop**, click Current Branch --\> New Branch

<img src="Images/create_new_ch_1_branch.png" 
     alt="GitHub Desktop screen where 'Current Branch' is selected and 'New Branch' button is visible" 
     style="width: 55%;">

- Name the branch 'chapter-01' and click 'Create Branch'

<img src="Images/name_new_branch_ch_1.png" 
     alt="GitHub Desktop screen upon creation of new branch, a name 'chapter-01' is given and 'Create Branch' button is visible in blue" 
     style="width: 55%;">

**Create Your First Quarto Notebook:**

1. Now, you can return to RStudio by launching the .Rproj file in your new directory

<img src="Images/launch_new_project.png" 
     alt="Screenshot of project folder with .Rproj file button" 
     style="width: 55%;">

2. Next, create a new Quarto document (.qmd file) where you can work on the examples, exercises, and type any notes you may want.

- File --\> New File --\> Quarto Document...

<img src="Images/create_new_quarto_file.png" 
     alt="RStudio screen showing button navigation to create a new quarto document"
     style="width: 55%;">

3. Name your Quarto document

- Title file 'Chapter 1'
- **deselect** 'Use visual markdown editor'
- Click 'Create Empty Document'

<img src="Images/name_new_quarto_file.png" 
     alt="RStudio screen upon creating new quarto document: title box changed to 'Chapter 1', 'Use visual markdown editor' is deselected, and 'Create Empty Document' button is present and circled in red."
     style="width: 55%;">

You will see something like the following...

<img src="Images/ch_1_quarto_file.png" 
     alt="RStudio screen with newly created 'Chapter 1' quarto document. The file is blank besides the YAML header with 'title: Chapter 1' and 'format: html'."
     style="width: 55%;">

4. Change the YAML Header

The section at the top of your document, enclosed by '---', is called the YAML header.
Currently, it specifies 'format: html', which renders your .qmd file as an HTML document.
When you "render" the document, Quarto combines your code, text, and raw data into a finished document.
Changing the header of the document to 'format: gfm' ensures that the output is a markdown file.
We want to render to a gfm (GitHub Flavored Markdown), specifically, as it is optimized for viewing on GitHub.

<img src="Images/change_yaml_header.png" 
     alt="Cropped screenshot of top left corner of RStudio screen. The YAML header has the correct 'Chapter 1' title but the output format has been changed to 'format: gfm'."
     style="width: 55%;">

5. Install Packages and Enable Reproducibility

You have already initialized this project with renv, ensuring consistency of your package versions, and thus consistency when sharing or reproducing your work.
renv takes and saves a "photo" or "snapshot" of your current packages and versions and restores this exact setup when reopening or sharing the project.
You will do this step each time you install or update a package.
So, to start, let's install three packages.

In your **R Console**, install the 'tidyverse', 'palmerpenguins', and 'ggthemes' packages:

```{r install packages in R Console}
#| eval: false
# install core packages using renv
renv::install(c("tidyverse", "palmerpenguins", "ggthemes"))
```

This installation is using renv.
Like many things in R, there is **more than one way to achieve the same end goal**.
'renv::install()' automatically includes a snapshot of the packages and versions.
But, if you just run 'install.packages()', you can always run 'renv::snapshot()' to save the current packages and versions afterward.
This is always done in your R Console.

Now, you will switch to writing commands in your own **Quarto document**!
To do this, click the green "+C" button near the top of your RStudio page.

<img src="Images/create_code_chunk.png" 
     alt="RStudio screen navigated to the top by the green '+C' button, which is circled in red. This will create a new code chunk."
     style="width: 55%;">
     
(**Hint**: If you click the right side of the button, by the down arrow, you will notice there are many types of code you select.
For the purpose of the following examples and exercises, you will be using R.)

The following commands (**all** of the following, unless otherwise specified) can be run in your executable code chunks.

Load libraries from the installed packages.
Unlike installing packages, you will want to load the libraries every session.

To run a command from a code chunk, click the green arrow on the top right of the chunk.

<img src="Images/run_command_in_chunk.png" 
     alt="RStudio screen navigated to a executable code chunk, with the 'Run Current Chunk' green arrow button circled in red."
     style="width: 85%;">

```{r load libraries}
# load tidyverse library (you will use this in a lot of your data analysis!)
library(tidyverse)
# load palmerpenguins library (includes an example dataset)
library(palmerpenguins)
# load ggthemes library (offers colorblind safe color palette)
library(ggthemes)
```

AMAZING work! Now, let's *really* get into it.

------------------------------------------------------------------------

## Background Info

-   A **data frame** is a rectangular collection of **variables** (in the columns) and **observations** (in the rows).
In the context of **palmerpenguins**, a variable refers to an attribute of all the penguins, and an observation refers to all the attributes of a single penguin.
-   In the **tidyverse**, we use special data frames called **tibbles**

------------------------------------------------------------------------

## Creating a ggplot

**end goal**:

<img src="Images/penguin_flipper_to_mass_ggplot2.png" 
     alt="Scatterplot showing positive correlation between penguin flipper length and body mass across three species"
     style="width: 55%;">

**To begin**: Create a plot with the function ggplot(), which you will add **layers** to using different **arguments**.
The first argument of ggplot() is the dataset to be used in the graph: ggplot(data = penguins) creates an empty graph that is primed to display the penguins dataset.

```{r empty ggplot}
#| eval: false
ggplot(data = penguins)
```

Now we can tell ggplot() how we want to visualize our penguins data.
Our next argument is mapping, where we define how the variables in our dataset are mapped to visual properties (ie **aesthetics**) of the plot.
The mapping argument is always defined in the aes() function, and the x and y arguments of aes() specify which variables to map to the x and y axes.
Let's map flipper length to the x axis and body mass to the y axis.
(*as you type in variable names, you might notice them populate... select the correct name and press tab to autofill*)

```{r mapped ggplot}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
)
```

But how will our data be displayed in this now structured graph?
First, we need to define a **geom**: a geometrical object that a plot uses to represent data.
For example, bar charts use bar geoms with geom_bar(), line charts can be displayed with line geoms using geom_line(), and boxplots with geom_boxplot().
Let's create a scatterplot using a point geom with geom_point():

```{r scatterplot}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

You may have noticed the warning message "Warning: Removed 2 rows containing missing values or values outside the scale range (\`geom_point())".
We see this message because there are two penguins in our dataset with missing **values**.
This is important and may lead to common issues we will explore later; but for now we will suppress this warning so it isn't printed alongside every plot we make.

We can start to gather conclusions from our positively correlated scatterplot we have now created, but we should still be skeptical about the apparent relationship between two variables.
Are there any other variables that explain the relationship?
For example, does the relationship between flipper length and body mass differ by species?
Next, let's incorporate species into our plot.

```{r species specific scatterplot}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point()
```

When a categorical variable is mapped to an aesthetic, ggplot2 will automatically assign a unique value of the aesthetic (here a unique color) to each unique level of the variable (each of the three species), a process known as **scaling**.
ggplot2 will also add a legend that explains which values correspond to which levels.

Let's add a new layer: a smooth curve to easily visualize the relationship between the two variables atop the already created scatterplot.
Since this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: geom_smooth().
We will specify that we want to draw the line of best fit based on a linear model with method = "lm".

```{r line of best fit}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point() +
  geom_smooth(method = "lm")
```

WAIT! This doesn't look like our **end result** plot... think about why this may have happened.

Now let's try to match our expected ggplot which has one line of best fit.
Since we want points to be colored based on species but don’t want the lines to be separated out for them, we should specify color = species for geom_point() only.

```{r one line of best fit}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth(method = "lm")
```

Since people have different color perception, let's also use different shapes to represent each species of penguin.

```{r shape aesthetic}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth(method = "lm")
```

For our final touches, let's improve our labeling using the labs() function in a new layer.
Arguments within labs() include "title", "subtitle", axes "x" and "y", and legend specifications such as "color" or "shape".
Finally, we can improve our color palette to be colorblind safe with the scale_color_colorblind() function from the ggthemes package.

```{r improved labels}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) +
  scale_color_colorblind()
```

Now we have a beautifully labeled scatterplot of penguins' data that matches our **end goal**!

------------------------------------------------------------------------

## Exercises pt 1 of 3

1.  How many rows are in penguins? How many columns?

2.  What does the bill_depth_mm variable in the penguins data frame describe?
Read the help for ?penguins to find out.

3.  Make a scatterplot of bill_depth_mm vs. bill_length_mm.
That is, make a scatterplot with bill_depth_mm on the y-axis and bill_length_mm on the x-axis.
Describe the relationship between these two variables.

4.  What happens if you make a scatterplot of species vs. bill_depth_mm?
What might be a better choice of geom?

5.  Why does the following give an error and how would you fix it?

```{r ch 1 exercise pt 1 #5}
#| eval: false
ggplot(data = penguins) + 
  geom_point()
```

6.  What does the na.rm argument do in geom_point()?
What is the default value of the argument?
Create a scatterplot where you successfully use this argument set to TRUE.

7.  Add the following caption to the plot you made in the previous exercise: “Data come from the palmerpenguins package.”
(**Hint:** Take a look at the documentation for labs())

8.  Recreate the following visualization.
What aesthetic should bill_depth_mm be mapped to?
And should it be mapped at the global level or at the geom level?

<img src="Images/Ch1_Exercise_pt1_Q8.png" 
     alt="Scatterplot showing positive correlation between penguin flipper length and body mass across species with varying bill depths"
     style="width: 55%;">

9.  Run this code in your head and predict what the output will look like.
Then, run the code in R and check your predictions.

```{r ch 1 exercise pt 1 #9}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)
) +
  geom_point() +
  geom_smooth(se = FALSE)
```

10. Will these two graphs look different?
Why/why not?

```{r ch 1 exercise pt 1 #10}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point() +
  geom_smooth()

ggplot() +
  geom_point(
    data = penguins,
    mapping = aes(x = flipper_length_mm, y = body_mass_g)
  ) +
  geom_smooth(
    data = penguins,
    mapping = aes(x = flipper_length_mm, y = body_mass_g)
  )
```

------------------------------------------------------------------------

## ggplot2 calls

Now that you're getting the hang of it, let's start to transition to a more concise expression of ggplot2 code.
Typically, the first one or two arguments to a function are so important that you should know them by heart.
The first two arguments to ggplot() are "data" and "mapping", which will not be supplied in the remainder of the code.

Now, instead of...

```{r expanded code}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

... we can now more concisely write...

```{r concise code}
#| eval: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

Which still shows the same result... with less typing!
(**Hint**: in the future, you'll also learn about the pipe, another concise method).

------------------------------------------------------------------------

## Visualizing Distributions

How you visualize the distribution of a variable depends on the type of variable: **categorical** or **numerical**.

A variable is **categorical** if it can only take one of a small set of values.
To examine the distribution of a categorical variable, you can use a bar chart.
The height of the bars displays how many observations occurred with each x value.

```{r categorical bar plot}
#| eval: false
ggplot(penguins, aes(x = species)) +
  geom_bar()
```

In bar plots of categorical variables with non-ordered levels, like the penguin species above, it’s often preferable to reorder the bars based on their frequencies.
Doing so requires transforming the variable to a factor and then reordering the levels of that factor.

```{r ordered categorical bar plot}
#| eval: false
ggplot(penguins, aes(x = fct_infreq(species))) +
  geom_bar()
```

A variable is **numerical** (or quantitative) if it can take on a wide range of numerical values, and it is sensible to add, subtract, or take averages with those values.
Numerical variables can be continuous or discrete.

One commonly used visualization for distributions of continuous variables is a histogram.

```{r numerical histogram}
#| eval: false
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200)
```

You can set the width of the intervals in a histogram with the binwidth argument, which is measured in the units of the x variable.
*You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns.*

```{r binwidth exploration}
#| eval: false
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20)
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000)
```

An alternative visualization for distributions of numerical variables is a **density plot**.

A **density plot** is a smoothed-out version of a histogram and a practical alternative, particularly for continuous data.
It shows fewer details than a histogram but can make it easier to quickly glean the shape of the distribution, particularly with respect to modes and skewness.

```{r density plot}
#| eval: false
ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()
```

------------------------------------------------------------------------

## Exercises pt 2 of 3

1.  Make a bar plot of species of penguins, where you assign species to the y aesthetic.
How is this plot different?

2.  How are the following two plots different?
Which aesthetic, color or fill, is more useful for changing the color of bars?

```{r ch 1 exercise pt 2 #2}
#| eval: false
ggplot(penguins, aes(x = species)) +
  geom_bar(color = "red")

ggplot(penguins, aes(x = species)) +
  geom_bar(fill = "red")
```

3.  What does the bins argument in geom_histogram() do?

4.  Make a histogram of the carat variable in the diamonds dataset that is available when you load the tidyverse package.
Experiment with different binwidths.
What binwidth reveals the most interesting patterns?

------------------------------------------------------------------------

## Visualizing Relationships

Now we will learn about commonly used plots for visualizing relationships between two or more variables and the geoms used for creating them.

To visualize the relationship between a numerical and a categorical variable we can use side-by-side **box plots**.
A **boxplot** is a type of visual shorthand for measures of position (percentiles) that describe a distribution.
It is also useful for identifying potential outliers.

Let’s take a look at the distribution of body mass by species using geom_boxplot():

```{r multivariable boxplot}
#| eval: false
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Alternatively, we can make density plots with geom_density().

```{r multivariable density plot}
#| eval: false
ggplot(penguins, aes(x = body_mass_g, color = species)) +
  geom_density(linewidth = 0.75)
```

We also customized the width of the lines using the linewidth argument.
Additionally, we can map species to both color and fill aesthetics and use the alpha aesthetic to add transparency to the filled density curves.
This aesthetic takes values between 0 (completely transparent) and 1 (completely opaque).

```{r filled density plot}
#| eval: false
ggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +
  geom_density(alpha = 0.5)
```

------------------------------------------------------------------------

## Two Categorical Variables

We can use stacked bar plots to visualize the relationship between two categorical variables.
For example, the following two stacked bar plots both display the relationship between island and species, or specifically, visualizing the distribution of species within each island.

We can plot the frequencies of each species of penguins on each island.
The plot shows that there are equal numbers of Adelies on each island but we don’t have a good sense of the percentage balance within each island.

```{r frequency plot}
#| eval: false
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
```

We can plot relative frequency by setting position = "fill" in the geom, which is more useful for comparing species distributions across islands since it’s not affected by the unequal numbers of penguins across the islands.

```{r relative frequency plot}
#| eval: false
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill")
```

In creating these bar charts, we map the variable that will be separated into bars to the x aesthetic, and the variable that will change the colors inside the bars to the fill aesthetic.

------------------------------------------------------------------------

## Two Numerical Variables

As shown previously with ggplot() + geom_point, a scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables.

------------------------------------------------------------------------

## Three or More Variables

We can incorporate more variables into a plot by mapping them to additional aesthetics.
For example, in the following scatterplot the colors of points represent species and the shapes of points represent islands.

```{r shape aesthetic scatterplot}
#| eval: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

However, some may view this display as cluttered.
Another way, which is particularly useful for categorical variables, is to split your plot into **facets**, subplots that each display one subset of the data.

To **facet** your plot by a single variable, use facet_wrap().
The first argument of facet_wrap() is a formula, which you create with \~ followed by a variable name.
The variable that you pass to facet_wrap() should be categorical.

```{r facet wrap}
#| eval: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  facet_wrap(~island)
```

------------------------------------------------------------------------

## Exercises pt 3 of 3

1.  The mpg data frame that is bundled with the ggplot2 package contains 234 observations collected by the US Environmental Protection Agency on 38 car models.
Which variables in mpg are categorical?
Which variables are numerical?
(**Hint**: Type ?mpg to read the documentation for the dataset.)
How can you see this information when you run mpg?

2.  Make a scatterplot of hwy vs. displ using the mpg data frame.
Next, map a third, numerical variable to color, then size, then both color and size, then shape.
How do these aesthetics behave differently for categorical vs. numerical variables?

3.  In the scatterplot of hwy vs. displ, what happens if you map a third variable to linewidth?

4.  What happens if you map the same variable to multiple aesthetics?

5.  Make a scatterplot of bill_depth_mm vs. bill_length_mm and color the points by species.
What does adding coloring by species reveal about the relationship between these two variables?
What about faceting by species?

6.  Why does the following yield two separate legends?
How would you fix it to combine the two legends?

```{r ch 1 exercise pt 3 #6}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_length_mm, y = bill_depth_mm, 
    color = species, shape = species
  )
) +
  geom_point() +
  labs(color = "Species")
```

7.  Create the two following stacked bar plots.
Which question can you answer with the first one?
Which question can you answer with the second one?

```{r ch 1 exercise pt 3 #7}
#| eval: false
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill")
ggplot(penguins, aes(x = species, fill = island)) +
  geom_bar(position = "fill")
```

------------------------------------------------------------------------

## Saving Your Plots

Once you’ve made a plot, you might want to get it out of R by saving it as an image that you can use elsewhere.
That’s the job of ggsave(), which will save the plot most recently created.
The format looks like this:

```{r save your plot}
#| eval: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point() ggsave(filename = "penguin-plot.png")
```

This will save your plot to your working directory, a concept you’ll learn more about in Chapter 6.
If you don’t specify the width and height they will be taken from the dimensions of the current plotting device.
For reproducible code, you’ll want to specify them.
 
------------------------------------------------------------------------

## Common Problems

As you start to run R code, you’re likely to run into problems.
Don’t worry — it happens to everyone.

Start by carefully comparing the code that you’re running to the code in the instructions.
R is extremely picky, and a misplaced character can make all the difference.
Make sure that every ( is matched with a ) and every " is paired with another ".

If you’re still stuck, try the **help**.
You can get help about any R function by running ?function_name in the console, or highlighting the function name and pressing F1 in RStudio.
Don’t worry if the help doesn’t seem that helpful - instead skip down to the examples and look for code that matches what you’re trying to do.

If that doesn’t help, carefully read the **error message**.
Sometimes the answer will be buried there!
But when you’re new to R, even if the answer is in the error message, you might not yet know how to understand it.
Another great tool is **Google**: try googling the error message, as it’s likely someone else has had the same problem, and has gotten help online.

------------------------------------------------------------------------

**You have completed your first chapter!**
Now, remember that Chapter 1 branch you created?
You are going to push all of your new Chapter 1 changes to that branch on GitHub, so your work will be viewable on the UCSC-Treehouse organization.
Lastly, you will request your mentor as a 'reviewer', so they can check over your work *before* you officially push it to the main branch.

Navigate back to **GitHub Desktop**...
You should see your new changes highlighted in red.

1. Push new Chapter 1 changes to chapter-01 branch

<img src="Images/push_ch_1_to_ch_1_branch.png" 
     alt="Cropped image of bottom left corder of GitHub Desktop screen where description 'Create and complete chapter 1' is given and blue 'Commit 1 file to chapter-01' button is visible at the bottom."
     style="width: 55%;">

2. Publish the new chapter-01 branch

<img src="Images/publish_ch_1_branch.png" 
     alt="GitHub Desktop screen where blue 'Publish branch' button is present and circled in red."
     style="width: 55%;">

3. Create a pull request

<img src="Images/create_pull_request.png" 
     alt="GitHub Desktop screen after committing changes to new branch, prompted to click 'Create Pull Request' button in blue."
     style="width: 55%;">

You will be relocated to the **GitHub browser**.

1. Add your mentor as a reviewer (**Note**: here I use 'hbeale' but make sure you are adding *your* mentor's GitHub id)

<img src="Images/add_reviewer_to_pull_request.png" 
     alt="GitHub browser screen upon creating a pull request. On the righthand side, a reviewer is added. The example shows 'hbeale' as reviewer, circled in red."
     style="width: 55%;">

Now your mentor can review your work while making some suggested changes, where needed.
After your mentor does this, when you return to GitHub Desktop and are under the 'chapter-01' branch, you will see your saved, unchanged work in **green** and your mentor's changes (or any new changes you have made too) in **red**.
The red signifies *any* new change that has not been committed and pushed to a branch.

------------------------------------------------------------------------

**NEXT UP:** [Chapter 2](https://github.com/UCSC-Treehouse/Essential-skills-for-Treehouse-computational-research/blob/main/Chapter-Instructions/Chapter_02_Instructions.md)